{"version":3,"file":"vue3-isotope.umd.cjs","sources":["../src/components/VueIsotope.vue","../src/index.ts"],"sourcesContent":["<script setup lang=\"ts\">\nimport type { IsotopeOptions } from 'isotope-layout'\nimport Isotope from 'isotope-layout'\nimport { computed, nextTick, onBeforeUnmount, onMounted, ref, useTemplateRef, watch } from 'vue'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ItemDataType = any\n// Match Isotope's own Elements type more closely\ntype Elements = Element | Element[] | HTMLElement | HTMLElement[] | string | NodeList\n\nexport interface SortDefinition {\n  [key: string]:\n    | ((item: ItemDataType, index?: number) => string | number)\n    | ((elem: Element) => string | number)\n    | string\n}\n\nexport interface FilterDefinition {\n  // Ensure filter functions return boolean, as expected by Isotope when mapped from data\n  [key: string]: (item: ItemDataType, index?: number) => boolean\n}\n\nexport interface ExtendedIsotopeOptions extends Omit<IsotopeOptions, 'getSortData'> {\n  getSortData?: SortDefinition | undefined\n  getFilterData?: FilterDefinition | undefined\n  isJQueryFiltering?: boolean | undefined\n}\n\n// Create a separate interface that doesn't extend Isotope to avoid type conflicts\nexport interface IsotopeInstance extends Omit<Isotope, 'updateSortData'> {\n  options?: ExtendedIsotopeOptions // from Outlayer options\n  // https://github.com/metafizzy/outlayer/blob/fc751c12a0448c89a9da7caa88dd35de0a789f08/outlayer.js#L175\n  items?: Array<{ element: Element }> // from Outlayer items\n  updateSortData(elements?: Elements): void\n  // destroy(): void\n  // reloadItems?(): void\n  arrange(options?: IsotopeOptions): void\n  // shuffle(): void\n  // getFilteredItemElements(): Element[]\n}\n\n// Custom deep equality function to replace lodash's isEqual\nfunction deepEqual(a: unknown, b: unknown): boolean {\n  // Check if primitives or if strictly equal (same reference)\n  if (a === b) return true\n\n  // Check if either is null/undefined but not both (we already checked a === b)\n  if (a == null || b == null) return false\n\n  // Check if same type\n  if (typeof a !== typeof b) return false\n\n  // Handle arrays\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false\n    }\n    return true\n  }\n\n  // Handle objects (but not functions, DOM nodes, etc)\n  if (typeof a === 'object' && typeof b === 'object') {\n    // Skip non-plain objects like DOM nodes or different classes\n    const aIsPlainObj = Object.getPrototypeOf(a) === Object.prototype\n    const bIsPlainObj = Object.getPrototypeOf(b) === Object.prototype\n\n    if (!aIsPlainObj || !bIsPlainObj) return false\n\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n\n    if (aKeys.length !== bKeys.length) return false\n\n    return aKeys.every(\n      (key) =>\n        // Ensure key exists on both objects and values are deep equal\n        Object.prototype.hasOwnProperty.call(b, key) &&\n        deepEqual((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key])\n    )\n  }\n\n  // Functions, Dates, RegExps, etc\n  return false\n}\n\nexport interface Props {\n  list: ItemDataType[]\n  itemSelector: string\n  options: ExtendedIsotopeOptions\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  itemSelector: 'vue-isotope-item',\n  options: () => ({\n    layoutMode: 'masonry',\n    masonry: {\n      gutter: 10\n    }\n  })\n})\n\n// Define Emits (vue 3.3+)\nconst emit = defineEmits<{\n  arrange: [options: IsotopeOptions]\n  layout: [layoutMode: LayoutMode]\n  filter: [filterName: string | ((item: ItemDataType, index?: number) => boolean) | null]\n  sort: [sortBy: string | string[] | null]\n  shuffle: []\n}>()\n\n// useTemplateRef (vue 3.5+)\nconst isotopeElement = useTemplateRef('isotopeElement')\n\n// Isotope Instance Ref\nconst iso = ref<IsotopeInstance | null>(null)\n\n// Watcher Management\nconst sortWatchers = ref<(() => void)[]>([])\nconst filterWatchers = ref<(() => void)[]>([])\nconst listWatcher = ref<(() => void) | null>(null)\nconst optionsWatcher = ref<(() => void) | null>(null)\n\n// Internal state for debouncing updates\nconst willUpdate = ref(false)\n\n// Helper to get child elements, filtering out text nodes, comments, etc.\nfunction getValidChildren(element: HTMLElement | null): Element[] {\n  if (!element) return []\n  // Directly use element.children which only includes Element nodes\n  return Array.from(element.children)\n}\n\n// Helper to add data-index attribute to each child element\nfunction addDataIndexAttributes(element: HTMLElement | null) {\n  if (!element) return\n  const children = getValidChildren(element)\n  children.forEach((child, idx) => {\n    child.setAttribute('data-index', String(idx))\n  })\n}\n\n// Computed options processor\nconst compiledOptions = computed<ExtendedIsotopeOptions>(() => {\n  const options: ExtendedIsotopeOptions = {\n    ...props.options,\n    // Ensure itemSelector starts with '.' if it's intended as a class selector\n    itemSelector: props.itemSelector?.startsWith('.')\n      ? props.itemSelector\n      : `.${props.itemSelector}`,\n    isJQueryFiltering: false // Important for non-jQuery environments\n  }\n\n  // Convert string shortcuts to functions for getSortData\n  if (options.getSortData) {\n    options.getSortData = Object.entries(options.getSortData).reduce((acc, [key, value]) => {\n      let fn: ((item: ItemDataType, index?: number) => string | number) | undefined\n      if (typeof value === 'string') {\n        const propName = value\n        fn = (item: ItemDataType): string | number => {\n          if (item && typeof item === 'object' && propName in item) {\n            const propValue = (item as Record<string, unknown>)[propName]\n            if (typeof propValue === 'string' || typeof propValue === 'number') {\n              return propValue\n            }\n            return JSON.stringify(propValue ?? '')\n          }\n          return ''\n        }\n      } else if (typeof value === 'function') {\n        // Assert that the provided function matches the expected signature for 'fn'\n        fn = value as (item: ItemDataType, index?: number) => string | number\n      }\n      if (fn) {\n        // Wrap so Isotope receives a function that takes a DOM element\n        acc[key] = (elem: Element) => {\n          const idx = Number(elem.getAttribute('data-index'))\n          return !isNaN(idx) && props.list[idx] ? fn(props.list[idx], idx) : ''\n        }\n      }\n      return acc\n    }, {} as SortDefinition)\n  }\n\n  // Process getFilterData - Isotope expects filter functions to receive the element\n  if (options.getFilterData) {\n    const newFilterData: FilterDefinition = {}\n    for (const key in options.getFilterData) {\n      const value = options.getFilterData[key]\n      if (typeof value === 'function') {\n        newFilterData[key] = value\n      }\n    }\n    options.getFilterData = newFilterData\n  }\n\n  return options\n})\n\n// --- Internal Functions ---\n\nfunction requestUpdate() {\n  if (!iso.value || willUpdate.value) return\n  willUpdate.value = true\n  void nextTick(() => {\n    if (iso.value) {\n      iso.value.arrange()\n    }\n    willUpdate.value = false\n  })\n}\n\nfunction clearWatchers() {\n  sortWatchers.value.forEach((unwatch) => unwatch())\n  filterWatchers.value.forEach((unwatch) => unwatch())\n  sortWatchers.value = []\n  filterWatchers.value = []\n}\n\n// Store original getSortData for watcher use\nconst originalGetSortData = computed(() => {\n  if (!props.options.getSortData) return undefined\n  return Object.entries(props.options.getSortData).reduce((acc, [key, value]) => {\n    let fn: ((item: ItemDataType, index?: number) => string | number) | undefined\n    if (typeof value === 'string') {\n      const propName = value\n      fn = (item: ItemDataType): string | number => {\n        if (item && typeof item === 'object' && propName in item) {\n          const propValue = (item as Record<string, unknown>)[propName]\n          if (typeof propValue === 'string' || typeof propValue === 'number') {\n            return propValue\n          }\n          return JSON.stringify(propValue ?? '')\n        }\n        return ''\n      }\n    } else if (typeof value === 'function') {\n      // Assert that the provided function matches the expected signature for 'fn'\n      fn = value as (item: ItemDataType, index?: number) => string | number\n    }\n    if (fn) {\n      // Wrap so Isotope receives a function that takes a DOM element\n      acc[key] = fn\n    }\n    return acc\n  }, {} as SortDefinition)\n})\n\n// Set up watchers for individual item properties defined in getSortData\nfunction setupItemWatchers() {\n  clearWatchers()\n  const sortDataDefs = originalGetSortData.value\n  if (sortDataDefs && typeof sortDataDefs === 'object') {\n    // Check it's an object\n    props.list.forEach((itemData, index) => {\n      // Iterate over the data list\n      if (!itemData) return // Skip null/undefined items\n      Object.keys(sortDataDefs).forEach((key) => {\n        const getter = sortDataDefs[key] as (item: ItemDataType, index?: number) => string | number\n        if (typeof getter === 'function') {\n          const unwatch = watch(\n            () => getter(itemData, index), // Watch the property on the data item\n            () => {\n              if (iso.value) {\n                iso.value.updateSortData() // Call without args to update all items\n                requestUpdate() // Debounced arrange\n              }\n            },\n            { deep: false } // Avoid deep watching individual properties unless necessary\n          )\n          sortWatchers.value.push(unwatch)\n        }\n      })\n    })\n  }\n}\n\n// Adds the itemSelector class to direct children elements if missing\nfunction ensureItemClasses(element: HTMLElement | null) {\n  if (!element) return\n  let classAdded = false\n  const children = getValidChildren(element)\n  children.forEach((child, idx) => {\n    if (!child.classList.contains(props.itemSelector)) {\n      child.classList.add(props.itemSelector)\n      classAdded = true\n    }\n    child.setAttribute('data-index', String(idx))\n  })\n  return classAdded\n}\n\nfunction initializeIsotope() {\n  if (!isotopeElement.value || iso.value) return\n\n  // Ensure children have the necessary class before initializing Isotope\n  ensureItemClasses(isotopeElement.value)\n\n  const options = compiledOptions.value\n  console.log('Initializing Isotope with options:', options)\n  // Use a more specific type assertion for Isotope constructor\n  const instance = new Isotope(\n    isotopeElement.value,\n    options as unknown as IsotopeOptions\n  ) as IsotopeInstance\n\n  iso.value = instance\n  setupItemWatchers()\n}\n\nfunction destroyIsotope() {\n  if (iso.value) {\n    iso.value.destroy()\n    iso.value = null\n  }\n  clearWatchers()\n  // Stop main watchers if they exist\n  listWatcher.value?.()\n  optionsWatcher.value?.()\n  listWatcher.value = null\n  optionsWatcher.value = null\n}\n\n// --- Lifecycle Hooks ---\n\nonMounted(() => {\n  // Initialize after the first render and DOM is available\n  void nextTick(() => {\n    initializeIsotope()\n    addDataIndexAttributes(isotopeElement.value)\n  })\n\n  // Watch for list changes (additions/removals/reorders)\n  listWatcher.value = watch(\n    () => props.list,\n    async () => {\n      await nextTick() // Wait for Vue to update the DOM based on list change\n      if (iso.value && isotopeElement.value) {\n        ensureItemClasses(isotopeElement.value) // Ensure new items have class\n        addDataIndexAttributes(isotopeElement.value)\n        iso.value.reloadItems?.() // Tell Isotope to re-read the DOM\n        setupItemWatchers() // Re-setup watchers for the new list data\n        requestUpdate() // Arrange with debouncing\n      } else {\n        // If isotope wasn't initialized yet, try again\n        initializeIsotope()\n        addDataIndexAttributes(isotopeElement.value)\n      }\n    },\n    { deep: true }\n  ) // Deep watch is often necessary if item objects are mutated\n\n  // Watch for option changes\n  optionsWatcher.value = watch(\n    compiledOptions,\n    (newOptions, oldOptions) => {\n      // console.log(\"Compiled options changed\", newOptions, oldOptions);\n      if (!iso.value || deepEqual(newOptions, oldOptions)) return\n\n      // If only layoutMode, filter, or sortBy changed, just call arrange\n      const layoutChanged = newOptions.layoutMode !== oldOptions.layoutMode\n      const filterChanged = newOptions.filter !== oldOptions.filter\n      const sortChanged = !deepEqual(newOptions.sortBy, oldOptions.sortBy)\n\n      if (layoutChanged || filterChanged || sortChanged) {\n        console.log('Arranging due to option change (layout/filter/sort)')\n        iso.value.arrange(newOptions as IsotopeOptions)\n      }\n\n      // If getSortData or getFilterData changed, update them and watchers\n      const sortDataChanged = !deepEqual(newOptions.getSortData, oldOptions.getSortData)\n      const filterDataChanged = !deepEqual(newOptions.getFilterData, oldOptions.getFilterData)\n\n      if (sortDataChanged) {\n        console.log('Updating sort data')\n        if (iso.value.options && newOptions.getSortData) {\n          iso.value.options.getSortData = newOptions.getSortData // Update isotope's internal options\n        }\n        setupItemWatchers() // Re-setup watchers\n        iso.value.updateSortData() // Update all items\n        requestUpdate()\n      }\n      if (filterDataChanged) {\n        console.log('Updating filter data (Note: mapping might be required)')\n        if (iso.value.options && newOptions.getFilterData) {\n          iso.value.options.getFilterData = newOptions.getFilterData\n        }\n        // No direct isotope method to update filter functions, re-arranging might be needed if filter changes\n        // setupItemWatchers(); // If watchers were used for filters\n        // requestUpdate();\n      }\n\n      // For other changes, a full re-init might be safest, but less performant.\n      // Example: if itemSelector changes, re-init is needed.\n      if (newOptions.itemSelector !== oldOptions.itemSelector) {\n        console.log('Re-initializing due to itemSelector change.')\n        destroyIsotope()\n        void nextTick(initializeIsotope)\n      }\n    },\n    { deep: true }\n  )\n})\n\nonBeforeUnmount(() => {\n  destroyIsotope()\n})\n\n// --- Exposed Methods ---\n\nfunction arrange(options: IsotopeOptions) {\n  if (iso.value) {\n    iso.value.arrange(options)\n    emit('arrange', options)\n  }\n}\n\n// Define a type for the allowed layout modes\ntype LayoutMode = NonNullable<IsotopeOptions['layoutMode']>\n\nfunction layout(layoutMode: LayoutMode) {\n  const options = { layoutMode }\n  arrange(options)\n  emit('layout', layoutMode)\n}\n\nfunction sort(sortBy: string | string[]) {\n  const options = { sortBy }\n  arrange(options)\n  emit('sort', sortBy)\n}\n\nfunction getDataIndexFilter(filterFn: (item: ItemDataType, index?: number) => boolean) {\n  return (elem: Element) => {\n    const idx = Number(elem.getAttribute('data-index'))\n    return !isNaN(idx) && props.list[idx] ? filterFn(props.list[idx], idx) : false\n  }\n}\n\nfunction getFilterArg(\n  filterName: string | ((item: ItemDataType, index?: number) => boolean)\n): string | ((elem: Element) => boolean) | undefined {\n  if (typeof filterName === 'function') {\n    return getDataIndexFilter(filterName)\n  }\n  const filterFunc = compiledOptions.value.getFilterData?.[filterName]\n  return typeof filterFunc === 'function' ? getDataIndexFilter(filterFunc) : filterName\n}\n\nfunction filter(filterName: string | ((item: ItemDataType, index?: number) => boolean) | null) {\n  if (filterName === null) {\n    unfilter()\n    return\n  }\n\n  const filterArg = getFilterArg(filterName)\n\n  if (filterArg !== undefined) {\n    arrange({ filter: filterArg })\n    emit('filter', filterName) // Emit the original name/function\n  } else {\n    console.error(\n      `Cannot apply filter: \"${String(filterName)}\". It's not a valid selector, not found in getFilterData, or function-based filtering failed due to mapping issues.`\n    )\n  }\n}\n\nfunction unfilter() {\n  arrange({ filter: '*' }) // Use '*' selector to show all\n  emit('filter', null)\n}\n\nfunction shuffle() {\n  if (iso.value) {\n    iso.value.shuffle()\n    emit('shuffle')\n    emit('sort', null) // Shuffle overrides sort\n  }\n}\n\nfunction getFilteredItemElements(): Element[] {\n  return iso.value?.getFilteredItemElements() || []\n}\n\nfunction getElementItems(): Element[] {\n  // Isotope v3+ stores item instances in the 'items' array\n  return iso.value?.items?.map((item) => item.element) || []\n}\n\n// Expose methods to parent components\ndefineExpose({\n  arrange,\n  filter,\n  unfilter,\n  layout,\n  sort,\n  shuffle,\n  getFilteredItemElements,\n  getElementItems,\n  iso // Expose the Isotope instance itself if needed\n})\n</script>\n\n<template>\n  <div ref=\"isotopeElement\">\n    <slot></slot>\n  </div>\n</template>\n","import type { App, Plugin } from 'vue'\nimport VueIsotopeComponent from './components/VueIsotope.vue'\n\nconst install: Plugin = (app: App) => {\n  app.component('VueIsotope', VueIsotopeComponent)\n}\n\n// Attach the install function directly to the component object.\n// Use a type assertion with an intersection type to inform TypeScript\n// that this object now also has an 'install' property.\nconst VueIsotope = VueIsotopeComponent as typeof VueIsotopeComponent & { install: Plugin }\nVueIsotope.install = install\n\nexport default VueIsotope\n"],"names":["deepEqual","a","b","i","aIsPlainObj","bIsPlainObj","aKeys","bKeys","key","props","__props","emit","__emit","isotopeElement","useTemplateRef","iso","ref","sortWatchers","filterWatchers","listWatcher","optionsWatcher","willUpdate","getValidChildren","element","addDataIndexAttributes","child","idx","compiledOptions","computed","options","_a","acc","value","fn","propName","item","propValue","elem","newFilterData","requestUpdate","nextTick","clearWatchers","unwatch","originalGetSortData","setupItemWatchers","sortDataDefs","itemData","index","getter","watch","ensureItemClasses","classAdded","initializeIsotope","instance","Isotope","destroyIsotope","_b","onMounted","newOptions","oldOptions","layoutChanged","filterChanged","sortChanged","sortDataChanged","filterDataChanged","onBeforeUnmount","arrange","layout","layoutMode","sort","sortBy","getDataIndexFilter","filterFn","getFilterArg","filterName","filterFunc","filter","unfilter","filterArg","shuffle","getFilteredItemElements","getElementItems","__expose","install","app","VueIsotopeComponent","VueIsotope"],"mappings":"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"}