{"version":3,"file":"vue3-isotope.js","sources":["../src/components/VueIsotope.vue","../src/index.ts"],"sourcesContent":["<script setup lang=\"ts\">\nimport type { IsotopeOptions } from 'isotope-layout'\nimport Isotope from 'isotope-layout'\nimport { computed, nextTick, onBeforeUnmount, onMounted, ref, useTemplateRef, watch } from 'vue'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ItemDataType = any\n// Match Isotope's own Elements type more closely\ntype Elements = Element | Element[] | HTMLElement | HTMLElement[] | string | NodeList\n\nexport interface SortDefinition {\n  [key: string]:\n    | ((item: ItemDataType, index?: number) => string | number)\n    | ((elem: Element) => string | number)\n    | string\n}\n\nexport interface FilterDefinition {\n  // Ensure filter functions return boolean, as expected by Isotope when mapped from data\n  [key: string]: (item: ItemDataType, index?: number) => boolean\n}\n\nexport interface ExtendedIsotopeOptions extends Omit<IsotopeOptions, 'getSortData'> {\n  getSortData?: SortDefinition | undefined\n  getFilterData?: FilterDefinition | undefined\n  isJQueryFiltering?: boolean | undefined\n}\n\n// Create a separate interface that doesn't extend Isotope to avoid type conflicts\nexport interface IsotopeInstance extends Omit<Isotope, 'updateSortData'> {\n  options?: ExtendedIsotopeOptions // from Outlayer options\n  // https://github.com/metafizzy/outlayer/blob/fc751c12a0448c89a9da7caa88dd35de0a789f08/outlayer.js#L175\n  items?: Array<{ element: Element }> // from Outlayer items\n  updateSortData(elements?: Elements): void\n  // destroy(): void\n  // reloadItems?(): void\n  arrange(options?: IsotopeOptions): void\n  // shuffle(): void\n  // getFilteredItemElements(): Element[]\n}\n\n// Custom deep equality function to replace lodash's isEqual\nfunction deepEqual(a: unknown, b: unknown): boolean {\n  // Check if primitives or if strictly equal (same reference)\n  if (a === b) return true\n\n  // Check if either is null/undefined but not both (we already checked a === b)\n  if (a == null || b == null) return false\n\n  // Check if same type\n  if (typeof a !== typeof b) return false\n\n  // Handle arrays\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false\n    }\n    return true\n  }\n\n  // Handle objects (but not functions, DOM nodes, etc)\n  if (typeof a === 'object' && typeof b === 'object') {\n    // Skip non-plain objects like DOM nodes or different classes\n    const aIsPlainObj = Object.getPrototypeOf(a) === Object.prototype\n    const bIsPlainObj = Object.getPrototypeOf(b) === Object.prototype\n\n    if (!aIsPlainObj || !bIsPlainObj) return false\n\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n\n    if (aKeys.length !== bKeys.length) return false\n\n    return aKeys.every(\n      (key) =>\n        // Ensure key exists on both objects and values are deep equal\n        Object.prototype.hasOwnProperty.call(b, key) &&\n        deepEqual((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key])\n    )\n  }\n\n  // Functions, Dates, RegExps, etc\n  return false\n}\n\nexport interface Props {\n  list: ItemDataType[]\n  itemSelector: string\n  options: ExtendedIsotopeOptions\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  itemSelector: 'vue-isotope-item',\n  options: () => ({\n    layoutMode: 'masonry',\n    masonry: {\n      gutter: 10\n    }\n  })\n})\n\n// Define Emits (vue 3.3+)\nconst emit = defineEmits<{\n  arrange: [options: IsotopeOptions]\n  layout: [layoutMode: LayoutMode]\n  filter: [filterName: string | ((item: ItemDataType, index?: number) => boolean) | null]\n  sort: [sortBy: string | string[] | null]\n  shuffle: []\n}>()\n\n// useTemplateRef (vue 3.5+)\nconst isotopeElement = useTemplateRef('isotopeElement')\n\n// Isotope Instance Ref\nconst iso = ref<IsotopeInstance | null>(null)\n\n// Watcher Management\nconst sortWatchers = ref<(() => void)[]>([])\nconst filterWatchers = ref<(() => void)[]>([])\nconst listWatcher = ref<(() => void) | null>(null)\nconst optionsWatcher = ref<(() => void) | null>(null)\n\n// Internal state for debouncing updates\nconst willUpdate = ref(false)\n\n// Helper to get child elements, filtering out text nodes, comments, etc.\nfunction getValidChildren(element: HTMLElement | null): Element[] {\n  if (!element) return []\n  // Directly use element.children which only includes Element nodes\n  return Array.from(element.children)\n}\n\n// Helper to add data-index attribute to each child element\nfunction addDataIndexAttributes(element: HTMLElement | null) {\n  if (!element) return\n  const children = getValidChildren(element)\n  children.forEach((child, idx) => {\n    child.setAttribute('data-index', String(idx))\n  })\n}\n\n// Computed options processor\nconst compiledOptions = computed<ExtendedIsotopeOptions>(() => {\n  const options: ExtendedIsotopeOptions = {\n    ...props.options,\n    // Ensure itemSelector starts with '.' if it's intended as a class selector\n    itemSelector: props.itemSelector?.startsWith('.')\n      ? props.itemSelector\n      : `.${props.itemSelector}`,\n    isJQueryFiltering: false // Important for non-jQuery environments\n  }\n\n  // Convert string shortcuts to functions for getSortData\n  if (options.getSortData) {\n    options.getSortData = Object.entries(options.getSortData).reduce((acc, [key, value]) => {\n      let fn: ((item: ItemDataType, index?: number) => string | number) | undefined\n      if (typeof value === 'string') {\n        const propName = value\n        fn = (item: ItemDataType): string | number => {\n          if (item && typeof item === 'object' && propName in item) {\n            const propValue = (item as Record<string, unknown>)[propName]\n            if (typeof propValue === 'string' || typeof propValue === 'number') {\n              return propValue\n            }\n            return JSON.stringify(propValue ?? '')\n          }\n          return ''\n        }\n      } else if (typeof value === 'function') {\n        // Assert that the provided function matches the expected signature for 'fn'\n        fn = value as (item: ItemDataType, index?: number) => string | number\n      }\n      if (fn) {\n        // Wrap so Isotope receives a function that takes a DOM element\n        acc[key] = (elem: Element) => {\n          const idx = Number(elem.getAttribute('data-index'))\n          return !isNaN(idx) && props.list[idx] ? fn(props.list[idx], idx) : ''\n        }\n      }\n      return acc\n    }, {} as SortDefinition)\n  }\n\n  // Process getFilterData - Isotope expects filter functions to receive the element\n  if (options.getFilterData) {\n    const newFilterData: FilterDefinition = {}\n    for (const key in options.getFilterData) {\n      const value = options.getFilterData[key]\n      if (typeof value === 'function') {\n        newFilterData[key] = value\n      }\n    }\n    options.getFilterData = newFilterData\n  }\n\n  return options\n})\n\n// --- Internal Functions ---\n\nfunction requestUpdate() {\n  if (!iso.value || willUpdate.value) return\n  willUpdate.value = true\n  void nextTick(() => {\n    if (iso.value) {\n      iso.value.arrange()\n    }\n    willUpdate.value = false\n  })\n}\n\nfunction clearWatchers() {\n  sortWatchers.value.forEach((unwatch) => unwatch())\n  filterWatchers.value.forEach((unwatch) => unwatch())\n  sortWatchers.value = []\n  filterWatchers.value = []\n}\n\n// Store original getSortData for watcher use\nconst originalGetSortData = computed(() => {\n  if (!props.options.getSortData) return undefined\n  return Object.entries(props.options.getSortData).reduce((acc, [key, value]) => {\n    let fn: ((item: ItemDataType, index?: number) => string | number) | undefined\n    if (typeof value === 'string') {\n      const propName = value\n      fn = (item: ItemDataType): string | number => {\n        if (item && typeof item === 'object' && propName in item) {\n          const propValue = (item as Record<string, unknown>)[propName]\n          if (typeof propValue === 'string' || typeof propValue === 'number') {\n            return propValue\n          }\n          return JSON.stringify(propValue ?? '')\n        }\n        return ''\n      }\n    } else if (typeof value === 'function') {\n      // Assert that the provided function matches the expected signature for 'fn'\n      fn = value as (item: ItemDataType, index?: number) => string | number\n    }\n    if (fn) {\n      // Wrap so Isotope receives a function that takes a DOM element\n      acc[key] = fn\n    }\n    return acc\n  }, {} as SortDefinition)\n})\n\n// Set up watchers for individual item properties defined in getSortData\nfunction setupItemWatchers() {\n  clearWatchers()\n  const sortDataDefs = originalGetSortData.value\n  if (sortDataDefs && typeof sortDataDefs === 'object') {\n    // Check it's an object\n    props.list.forEach((itemData, index) => {\n      // Iterate over the data list\n      if (!itemData) return // Skip null/undefined items\n      Object.keys(sortDataDefs).forEach((key) => {\n        const getter = sortDataDefs[key] as (item: ItemDataType, index?: number) => string | number\n        if (typeof getter === 'function') {\n          const unwatch = watch(\n            () => getter(itemData, index), // Watch the property on the data item\n            () => {\n              if (iso.value) {\n                iso.value.updateSortData() // Call without args to update all items\n                requestUpdate() // Debounced arrange\n              }\n            },\n            { deep: false } // Avoid deep watching individual properties unless necessary\n          )\n          sortWatchers.value.push(unwatch)\n        }\n      })\n    })\n  }\n}\n\n// Adds the itemSelector class to direct children elements if missing\nfunction ensureItemClasses(element: HTMLElement | null) {\n  if (!element) return\n  let classAdded = false\n  const children = getValidChildren(element)\n  children.forEach((child, idx) => {\n    if (!child.classList.contains(props.itemSelector)) {\n      child.classList.add(props.itemSelector)\n      classAdded = true\n    }\n    child.setAttribute('data-index', String(idx))\n  })\n  return classAdded\n}\n\nfunction initializeIsotope() {\n  if (!isotopeElement.value || iso.value) return\n\n  // Ensure children have the necessary class before initializing Isotope\n  ensureItemClasses(isotopeElement.value)\n\n  const options = compiledOptions.value\n  console.log('Initializing Isotope with options:', options)\n  // Use a more specific type assertion for Isotope constructor\n  const instance = new Isotope(\n    isotopeElement.value,\n    options as unknown as IsotopeOptions\n  ) as IsotopeInstance\n\n  iso.value = instance\n  setupItemWatchers()\n}\n\nfunction destroyIsotope() {\n  if (iso.value) {\n    iso.value.destroy()\n    iso.value = null\n  }\n  clearWatchers()\n  // Stop main watchers if they exist\n  listWatcher.value?.()\n  optionsWatcher.value?.()\n  listWatcher.value = null\n  optionsWatcher.value = null\n}\n\n// --- Lifecycle Hooks ---\n\nonMounted(() => {\n  // Initialize after the first render and DOM is available\n  void nextTick(() => {\n    initializeIsotope()\n    addDataIndexAttributes(isotopeElement.value)\n  })\n\n  // Watch for list changes (additions/removals/reorders)\n  listWatcher.value = watch(\n    () => props.list,\n    async () => {\n      await nextTick() // Wait for Vue to update the DOM based on list change\n      if (iso.value && isotopeElement.value) {\n        ensureItemClasses(isotopeElement.value) // Ensure new items have class\n        addDataIndexAttributes(isotopeElement.value)\n        iso.value.reloadItems?.() // Tell Isotope to re-read the DOM\n        setupItemWatchers() // Re-setup watchers for the new list data\n        requestUpdate() // Arrange with debouncing\n      } else {\n        // If isotope wasn't initialized yet, try again\n        initializeIsotope()\n        addDataIndexAttributes(isotopeElement.value)\n      }\n    },\n    { deep: true }\n  ) // Deep watch is often necessary if item objects are mutated\n\n  // Watch for option changes\n  optionsWatcher.value = watch(\n    compiledOptions,\n    (newOptions, oldOptions) => {\n      // console.log(\"Compiled options changed\", newOptions, oldOptions);\n      if (!iso.value || deepEqual(newOptions, oldOptions)) return\n\n      // If only layoutMode, filter, or sortBy changed, just call arrange\n      const layoutChanged = newOptions.layoutMode !== oldOptions.layoutMode\n      const filterChanged = newOptions.filter !== oldOptions.filter\n      const sortChanged = !deepEqual(newOptions.sortBy, oldOptions.sortBy)\n\n      if (layoutChanged || filterChanged || sortChanged) {\n        console.log('Arranging due to option change (layout/filter/sort)')\n        iso.value.arrange(newOptions as IsotopeOptions)\n      }\n\n      // If getSortData or getFilterData changed, update them and watchers\n      const sortDataChanged = !deepEqual(newOptions.getSortData, oldOptions.getSortData)\n      const filterDataChanged = !deepEqual(newOptions.getFilterData, oldOptions.getFilterData)\n\n      if (sortDataChanged) {\n        console.log('Updating sort data')\n        if (iso.value.options && newOptions.getSortData) {\n          iso.value.options.getSortData = newOptions.getSortData // Update isotope's internal options\n        }\n        setupItemWatchers() // Re-setup watchers\n        iso.value.updateSortData() // Update all items\n        requestUpdate()\n      }\n      if (filterDataChanged) {\n        console.log('Updating filter data (Note: mapping might be required)')\n        if (iso.value.options && newOptions.getFilterData) {\n          iso.value.options.getFilterData = newOptions.getFilterData\n        }\n        // No direct isotope method to update filter functions, re-arranging might be needed if filter changes\n        // setupItemWatchers(); // If watchers were used for filters\n        // requestUpdate();\n      }\n\n      // For other changes, a full re-init might be safest, but less performant.\n      // Example: if itemSelector changes, re-init is needed.\n      if (newOptions.itemSelector !== oldOptions.itemSelector) {\n        console.log('Re-initializing due to itemSelector change.')\n        destroyIsotope()\n        void nextTick(initializeIsotope)\n      }\n    },\n    { deep: true }\n  )\n})\n\nonBeforeUnmount(() => {\n  destroyIsotope()\n})\n\n// --- Exposed Methods ---\n\nfunction arrange(options: IsotopeOptions) {\n  if (iso.value) {\n    iso.value.arrange(options)\n    emit('arrange', options)\n  }\n}\n\n// Define a type for the allowed layout modes\ntype LayoutMode = NonNullable<IsotopeOptions['layoutMode']>\n\nfunction layout(layoutMode: LayoutMode) {\n  const options = { layoutMode }\n  arrange(options)\n  emit('layout', layoutMode)\n}\n\nfunction sort(sortBy: string | string[]) {\n  const options = { sortBy }\n  arrange(options)\n  emit('sort', sortBy)\n}\n\nfunction getDataIndexFilter(filterFn: (item: ItemDataType, index?: number) => boolean) {\n  return (elem: Element) => {\n    const idx = Number(elem.getAttribute('data-index'))\n    return !isNaN(idx) && props.list[idx] ? filterFn(props.list[idx], idx) : false\n  }\n}\n\nfunction getFilterArg(\n  filterName: string | ((item: ItemDataType, index?: number) => boolean)\n): string | ((elem: Element) => boolean) | undefined {\n  if (typeof filterName === 'function') {\n    return getDataIndexFilter(filterName)\n  }\n  const filterFunc = compiledOptions.value.getFilterData?.[filterName]\n  return typeof filterFunc === 'function' ? getDataIndexFilter(filterFunc) : filterName\n}\n\nfunction filter(filterName: string | ((item: ItemDataType, index?: number) => boolean) | null) {\n  if (filterName === null) {\n    unfilter()\n    return\n  }\n\n  const filterArg = getFilterArg(filterName)\n\n  if (filterArg !== undefined) {\n    arrange({ filter: filterArg })\n    emit('filter', filterName) // Emit the original name/function\n  } else {\n    console.error(\n      `Cannot apply filter: \"${String(filterName)}\". It's not a valid selector, not found in getFilterData, or function-based filtering failed due to mapping issues.`\n    )\n  }\n}\n\nfunction unfilter() {\n  arrange({ filter: '*' }) // Use '*' selector to show all\n  emit('filter', null)\n}\n\nfunction shuffle() {\n  if (iso.value) {\n    iso.value.shuffle()\n    emit('shuffle')\n    emit('sort', null) // Shuffle overrides sort\n  }\n}\n\nfunction getFilteredItemElements(): Element[] {\n  return iso.value?.getFilteredItemElements() || []\n}\n\nfunction getElementItems(): Element[] {\n  // Isotope v3+ stores item instances in the 'items' array\n  return iso.value?.items?.map((item) => item.element) || []\n}\n\n// Expose methods to parent components\ndefineExpose({\n  arrange,\n  filter,\n  unfilter,\n  layout,\n  sort,\n  shuffle,\n  getFilteredItemElements,\n  getElementItems,\n  iso // Expose the Isotope instance itself if needed\n})\n</script>\n\n<template>\n  <div ref=\"isotopeElement\">\n    <slot></slot>\n  </div>\n</template>\n","import type { App, Plugin } from 'vue'\nimport VueIsotopeComponent from './components/VueIsotope.vue'\n\nconst install: Plugin = (app: App) => {\n  app.component('VueIsotope', VueIsotopeComponent)\n}\n\n// Attach the install function directly to the component object.\n// Use a type assertion with an intersection type to inform TypeScript\n// that this object now also has an 'install' property.\nconst VueIsotope = VueIsotopeComponent as typeof VueIsotopeComponent & { install: Plugin }\nVueIsotope.install = install\n\nexport default VueIsotope\n"],"names":["deepEqual","a","b","i","aIsPlainObj","bIsPlainObj","aKeys","bKeys","key","props","__props","emit","__emit","isotopeElement","useTemplateRef","iso","ref","sortWatchers","filterWatchers","listWatcher","optionsWatcher","willUpdate","getValidChildren","element","addDataIndexAttributes","child","idx","compiledOptions","computed","options","_a","acc","value","fn","propName","item","propValue","elem","newFilterData","requestUpdate","nextTick","clearWatchers","unwatch","originalGetSortData","setupItemWatchers","sortDataDefs","itemData","index","getter","watch","ensureItemClasses","classAdded","initializeIsotope","instance","Isotope","destroyIsotope","_b","onMounted","newOptions","oldOptions","layoutChanged","filterChanged","sortChanged","sortDataChanged","filterDataChanged","onBeforeUnmount","arrange","layout","layoutMode","sort","sortBy","getDataIndexFilter","filterFn","getFilterArg","filterName","filterFunc","filter","unfilter","filterArg","shuffle","getFilteredItemElements","getElementItems","__expose","install","app","VueIsotopeComponent","VueIsotope"],"mappings":"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"}